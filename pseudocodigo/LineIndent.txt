STRUCT LineIndent:
    indentLevel: INTEGER
    lineWithoutIndent: STRING

FUNCTION createLineIndent(level: INTEGER, text: STRING) -> LineIndent:
    li = new LineIndent
    li.indentLevel = level
    li.lineWithoutIndent = text
    RETURN li


// ---------
// Constantes
// ---------

CONST TAB_SPACES = 4            // nº de espacios que equivalen a un nivel de indentación
CONST SPACE = ' '               // carácter espacio
CONST TAB = '\t'                // carácter tabulación

// Patrones (expresados de forma conceptual)
PATTERN EMPTY_LINE   = "^\s*$"          // línea con solo espacios en blanco
PATTERN COMMENT_LINE = "^\s*#.*$"       // línea con opcional espacio seguido de '#'
PATTERN COMPACT_LINE = "^\d+"          // línea que empieza por uno o más dígitos


// -----------------------------
// parseLine: línea -> LineIndent
// -----------------------------

FUNCTION parseLine(aLine: STRING, numLine: INTEGER, parseState: ParseState) 
        THROWS ParseException
        RETURNS LineIndent OR null:

    stackSize = tamaño de parseState.stack

    lastNodeMultiline = (stackSize > 0) 
                        AND NodeType.isMultiline( tope(parseState.stack).type )

    // 1) Si NO estamos dentro de un nodo multilínea:
    //    - líneas vacías y comentarios se ignoran completamente
    IF NOT lastNodeMultiline THEN
        IF aLine coincide con EMPTY_LINE 
           OR aLine coincide con COMMENT_LINE THEN
            RETURN null
        END IF
    END IF

    // 2) Línea "compacta": comienza con dígitos "nivel:contenido"
    IF aLine coincide con COMPACT_LINE EN EL INICIO THEN
        i = posición del primer carácter ':' en aLine
        levelStr = subcadena de aLine desde índice 0 hasta i (sin incluir i)
        textStr  = subcadena de aLine desde índice (i + 1) hasta el final

        level = convertir levelStr a entero

        RETURN createLineIndent(level, textStr)
    END IF

    // 3) Cálculo de indentación basada en espacios/tabs

    level   = 0
    spaces  = 0
    pointer = 0
    length  = longitud de aLine

    WHILE pointer < length DO
        charPointer = carácter de aLine en posición pointer

        IF charPointer == SPACE THEN
            spaces = spaces + 1

            IF spaces == TAB_SPACES THEN
                level = level + 1
                spaces = 0
            END IF

        ELSE IF charPointer == TAB THEN
            level = level + 1
            spaces = 0

        ELSE
            // Primer carácter no espacio/tab: fin de la indentación
            BREAK
        END IF

        pointer = pointer + 1

        // Si el último nodo es multilínea:
        // no permitimos que la indentación consumida supere el tamaño de la pila.
        // Esto evita "perder" indentación que pertenece al contenido de texto.
        IF lastNodeMultiline AND level >= stackSize THEN
            BREAK
        END IF
    END WHILE

    // 4) Validación de espacios sueltos
    // Si quedan espacios "sueltos" que no completan un TAB_SPACES, es error.
    IF spaces != 0 THEN
        THROW ParseException(
            line = numLine,
            code = "INVALID_INDENTATION",
            message = "Invalid number spaces"
        )
    END IF

    // 5) Tratamiento especial de multilínea cuando se ha reducido el nivel
    IF lastNodeMultiline AND level < stackSize THEN
        // 5.1) Línea vacía dentro de un bloque multilínea:
        //      se PRESERVA como texto vacío, asociada al nivel del nodo multilínea.
        IF aLine coincide con EMPTY_LINE THEN
            RETURN createLineIndent(stackSize, "")
        END IF

        // 5.2) Comentario a este nivel (o menos):
        //      se considera realmente comentario y se omite.
        IF aLine coincide con COMMENT_LINE THEN
            RETURN null
        END IF
    END IF

    // 6) Caso general: devolver la línea sin la indentación consumida
    textWithoutIndent = subcadena de aLine desde índice pointer hasta el final

    RETURN createLineIndent(level, textWithoutIndent)
